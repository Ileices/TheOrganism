# singularity_transmuter.py — Auto‑Converter: Legacy Code → Singularity Cell
# ──────────────────────────────────────────────────────────────────────────────
# PURPOSE
# ▫ Scan every file archived by gene_splicer_absorber (/absorptions)
# ▫ Detect if file already follows Singularity framework (RBY(), ensure_element…)
# ▫ If not, generate a *wrapped* Singularity module that:
#     • Imports the legacy module safely
#     • Registers every callable (functions + classes) into the Periodic Table
#     • Creates a thin RBY skeleton + glyph logging for each callable
# ▫ Drop the autogenerated module back into /user_touch so
#   gene_splicer_absorber can re‑ingest, test, and integrate it.
# ▫ Runs forever as its own self‑contained Singularity node.
# ──────────────────────────────────────────────────────────────────────────────

import ast
import importlib.util
import inspect
import logging
import textwrap
import uuid
import yaml
from decimal import Decimal
from pathlib import Path
import fake_singularity as core  # ← parent organism

# ─── Logging Setup ────────────────────────────────────────────────────────────
logger = logging.getLogger("singularity_transmuter")
logger.setLevel(logging.INFO)
fh = logging.FileHandler(core.MEMORY / "singularity_transmuter.log", encoding="utf-8")
fh.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
logger.addHandler(fh)

# ─── Directories ──────────────────────────────────────────────────────────────
ABSORPTIONS_DIR = core.ROOT / "absorptions"     # where gene_splicer archives raw files
TRANS_MUTED_DIR = core.ROOT / "transmuted"      # keep originals after wrapping
TRANS_MUTED_DIR.mkdir(parents=True, exist_ok=True)

# ─── Helpers ──────────────────────────────────────────────────────────────────
def is_singularity_code(source: str) -> bool:
    """Detect key framework markers to avoid re‑wrapping."""
    markers = ("def RBY(", "ensure_element(", "update_element_exec(", "glyph_from_rby(")
    return any(m in source for m in markers)

def classify_rby_minimal() -> dict:
    """Return a default subtle bias toward ‘Blue’ (cognition) for converters."""
    return {"R": Decimal("0.30"), "B": Decimal("0.40"), "Y": Decimal("0.30")}

def generate_wrapper(original_path: Path, callables: list, description: str) -> str:
    """
    Create a fully compliant Singularity wrapper around the legacy module.
    Each callable gets its own DNA entry at runtime.
    """
    mod_name = original_path.stem
    rby = classify_rby_minimal()

    wrapper = f'''\
# 🧬 {mod_name}_singularity.py — Autogenerated wrapper (DO NOT EDIT)
# Converts legacy module `{mod_name}` into a Singularity‑compliant cell.
import importlib.util, uuid, datetime, inspect
from decimal import Decimal
from pathlib import Path
import fake_singularity as core

# ─── Load legacy module dynamically ───────────────────────────────────────────
spec = importlib.util.spec_from_file_location("{mod_name}", r"{original_path.as_posix()}")
legacy = importlib.util.module_from_spec(spec)
spec.loader.exec_module(legacy)

# ─── RBY Signature for this cell ──────────────────────────────────────────────
CELL_RBY = core.RBY(Decimal("{rby['R']}"), Decimal("{rby['B']}"), Decimal("{rby['Y']}"))

# ─── DNA Registration Helpers ────────────────────────────────────────────────
def _register_callable(obj, name:str, doc:str):
    """Create Periodic Table element & generate glyph."""
    core.ensure_element(obj, CELL_RBY, doc or "legacy callable")
    core.update_element_exec(name, CELL_RBY)

# ─── Wrap each extracted callable ─────────────────────────────────────────────
'''

    for name, doc in callables:
        safe_name = f"{name}_wrapped"
        wrapper += f"""
def {safe_name}(*args, **kwargs):
    \"\"\"Wrapped legacy callable `{name}` → Singularity
    {doc or 'No docstring provided.'}
    \"\"\"
    _register_callable({safe_name}, "{name}", {repr(doc or 'legacy callable')})
    return getattr(legacy, "{name}")(*args, **kwargs)
"""

    # Optional: expose list for reflection
    wrapper += "\n__all__ = " + repr([f"{n}_wrapped" for n, _ in callables]) + "\n"
    return textwrap.dedent(wrapper)

# ─── Core Transmutation Logic ────────────────────────────────────────────────
def transmute_file(path: Path):
    logger.info(f"Transmuting {path.name}")
    src = path.read_text(encoding="utf-8", errors="replace")

    if is_singularity_code(src):
        logger.info(f"{path.name} already Singularity compliant. Skipping.")
        return

    if path.suffix.lower() != ".py":
        logger.info(f"{path.name} is not a Python file. Skipping.")
        return

    # Parse AST for top‑level functions/classes
    callables = []
    try:
        tree = ast.parse(src)
        for node in tree.body:
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                callables.append((node.name, ast.get_docstring(node)))
    except Exception as e:
        logger.error(f"AST parse error {path.name}: {e}")
        return

    if not callables:
        logger.info(f"No callables found in {path.name}. Skipping.")
        return

    # Use first docstring or filename as description
    description = callables[0][1] or path.stem
    wrapped_code = generate_wrapper(path, callables, description)

    # Write wrapped module back to /user_touch for re‑ingestion
    new_name = f"sing_{uuid.uuid4().hex}_{path.stem}.py"
    new_path = core.USER_TOUCH / new_name
    new_path.write_text(wrapped_code, encoding="utf-8")
    logger.info(f"Generated wrapper {new_name}")

    # Archive original into /transmuted
    path.replace(TRANS_MUTED_DIR / path.name)

def transmutation_loop(interval=5):
    """Forever scan absorptions → convert → output to user_touch."""
    while True:
        for f in list(ABSORPTIONS_DIR.iterdir()):
            if f.is_file():
                try:
                    transmute_file(f)
                except Exception as e:
                    logger.error(f"Transmutation failure {f.name}: {e}")
        # Log & sleep
        core.log("Transmutation cycle complete", "transmuter")
        time.sleep(interval)

# ─── RUN AS A SINGULARITY NODE ────────────────────────────────────────────────
if __name__ == "__main__":
    core.log("Singularity‑Transmuter starting", "init")
    transmutation_loop()
