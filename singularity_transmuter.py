# singularity_transmuter.py â€” Autoâ€‘Converter: Legacy Code â†’ Singularity Cell
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PURPOSE
# â–«â€¯Scan every file archived by gene_splicer_absorber (/absorptions)
# â–«â€¯Detect if file already follows Singularity framework (RBY(), ensure_elementâ€¦)
# â–«â€¯If not, generate a *wrapped* Singularity module that:
#     â€¢â€¯Imports the legacy module safely
#     â€¢â€¯Registers every callable (functions + classes) into the Periodic Table
#     â€¢â€¯Creates a thin RBY skeleton + glyph logging for each callable
# â–«â€¯Drop the autogenerated module back into /user_touch so
#   gene_splicer_absorber can reâ€‘ingest, test, and integrate it.
# â–«â€¯Runs forever as its own selfâ€‘contained Singularity node.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

import ast
import importlib.util
import inspect
import logging
import textwrap
import uuid
import yaml
from decimal import Decimal
from pathlib import Path
import fake_singularity as core  # â† parent organism

# â”€â”€â”€ Logging Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logger = logging.getLogger("singularity_transmuter")
logger.setLevel(logging.INFO)
fh = logging.FileHandler(core.MEMORY / "singularity_transmuter.log", encoding="utf-8")
fh.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
logger.addHandler(fh)

# â”€â”€â”€ Directories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ABSORPTIONS_DIR = core.ROOT / "absorptions"     # where gene_splicer archives raw files
TRANS_MUTED_DIR = core.ROOT / "transmuted"      # keep originals after wrapping
TRANS_MUTED_DIR.mkdir(parents=True, exist_ok=True)

# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def is_singularity_code(source: str) -> bool:
    """Detect key framework markers to avoid reâ€‘wrapping."""
    markers = ("def RBY(", "ensure_element(", "update_element_exec(", "glyph_from_rby(")
    return any(m in source for m in markers)

def classify_rby_minimal() -> dict:
    """Return a default subtle bias toward â€˜Blueâ€™ (cognition) for converters."""
    return {"R": Decimal("0.30"), "B": Decimal("0.40"), "Y": Decimal("0.30")}

def generate_wrapper(original_path: Path, callables: list, description: str) -> str:
    """
    Create a fully compliant Singularity wrapper around the legacy module.
    Each callable gets its own DNA entry at runtime.
    """
    mod_name = original_path.stem
    rby = classify_rby_minimal()

    wrapper = f'''\
# ðŸ§¬ {mod_name}_singularity.py â€” Autogenerated wrapper (DO NOT EDIT)
# Converts legacy module `{mod_name}` into a Singularityâ€‘compliant cell.
import importlib.util, uuid, datetime, inspect
from decimal import Decimal
from pathlib import Path
import fake_singularity as core

# â”€â”€â”€ Load legacy module dynamically â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
spec = importlib.util.spec_from_file_location("{mod_name}", r"{original_path.as_posix()}")
legacy = importlib.util.module_from_spec(spec)
spec.loader.exec_module(legacy)

# â”€â”€â”€ RBY Signature for this cell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CELL_RBY = core.RBY(Decimal("{rby['R']}"), Decimal("{rby['B']}"), Decimal("{rby['Y']}"))

# â”€â”€â”€ DNA Registration Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _register_callable(obj, name:str, doc:str):
    """Create Periodic Table element & generate glyph."""
    core.ensure_element(obj, CELL_RBY, doc or "legacy callable")
    core.update_element_exec(name, CELL_RBY)

# â”€â”€â”€ Wrap each extracted callable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
'''

    for name, doc in callables:
        safe_name = f"{name}_wrapped"
        wrapper += f"""
def {safe_name}(*args, **kwargs):
    \"\"\"Wrapped legacy callable `{name}` â†’ Singularity
    {doc or 'No docstring provided.'}
    \"\"\"
    _register_callable({safe_name}, "{name}", {repr(doc or 'legacy callable')})
    return getattr(legacy, "{name}")(*args, **kwargs)
"""

    # Optional: expose list for reflection
    wrapper += "\n__all__ = " + repr([f"{n}_wrapped" for n, _ in callables]) + "\n"
    return textwrap.dedent(wrapper)

# â”€â”€â”€ Core Transmutation Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def transmute_file(path: Path):
    logger.info(f"Transmuting {path.name}")
    src = path.read_text(encoding="utf-8", errors="replace")

    if is_singularity_code(src):
        logger.info(f"{path.name} already Singularity compliant. Skipping.")
        return

    if path.suffix.lower() != ".py":
        logger.info(f"{path.name} is not a Python file. Skipping.")
        return

    # Parse AST for topâ€‘level functions/classes
    callables = []
    try:
        tree = ast.parse(src)
        for node in tree.body:
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                callables.append((node.name, ast.get_docstring(node)))
    except Exception as e:
        logger.error(f"AST parse error {path.name}: {e}")
        return

    if not callables:
        logger.info(f"No callables found in {path.name}. Skipping.")
        return

    # Use first docstring or filename as description
    description = callables[0][1] or path.stem
    wrapped_code = generate_wrapper(path, callables, description)

    # Write wrapped module back to /user_touch for reâ€‘ingestion
    new_name = f"sing_{uuid.uuid4().hex}_{path.stem}.py"
    new_path = core.USER_TOUCH / new_name
    new_path.write_text(wrapped_code, encoding="utf-8")
    logger.info(f"Generated wrapper {new_name}")

    # Archive original into /transmuted
    path.replace(TRANS_MUTED_DIR / path.name)

def transmutation_loop(interval=5):
    """Forever scan absorptions â†’ convert â†’ output to user_touch."""
    while True:
        for f in list(ABSORPTIONS_DIR.iterdir()):
            if f.is_file():
                try:
                    transmute_file(f)
                except Exception as e:
                    logger.error(f"Transmutation failure {f.name}: {e}")
        # Log & sleep
        core.log("Transmutation cycle complete", "transmuter")
        time.sleep(interval)

# â”€â”€â”€ RUN AS A SINGULARITY NODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    core.log("Singularityâ€‘Transmuter starting", "init")
    transmutation_loop()
